@page "/"
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D

<h3>4D Hypercube Visualization</h3>
<div style="border:1px solid black; display:inline-block;">
    <BECanvas Width="800" Height="600" @ref="_canvasReference"></BECanvas>
</div>

@code {
    private Canvas2DContext? _context;
    private BECanvasComponent? _canvasReference;
    private List<double[]> _vertices = new();
    private const double Distance = 3.0; // Perspective projection distance

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Create the Canvas2D context
            _context = await _canvasReference!.CreateCanvas2DAsync();

            // Generate the 4D hypercube vertices
            _vertices = GenerateHypercubeVertices();

            // Draw the hypercube
            await DrawHypercubeAsync();
        }
    }

    // Generate vertices of a 4D hypercube
    private List<double[]> GenerateHypercubeVertices()
    {
        var vertices = new List<double[]>();
        for (int i = 0; i < 16; i++) // 2^4 vertices
        {
            var vertex = new double[4];
            for (int j = 0; j < 4; j++)
            {
                vertex[j] = (i & (1 << j)) == 0 ? -1 : 1; // Binary coordinates
            }
            vertices.Add(vertex);
        }
        return vertices;
    }

    // Project a 4D vertex to 2D
    private (double x, double y) ProjectVertex(double[] vertex)
    {
        // 4D to 3D perspective projection
        double wFactor = Distance / (Distance - vertex[3]);
        double x3D = vertex[0] * wFactor;
        double y3D = vertex[1] * wFactor;
        double z3D = vertex[2] * wFactor;

        // 3D to 2D projection
        double x2D = x3D / (Distance - z3D);
        double y2D = y3D / (Distance - z3D);

        // Scale and center on canvas
        double scale = 150.0; // Scale factor
        double offsetX = 400; // Canvas center X
        double offsetY = 300; // Canvas center Y

        return (x2D * scale + offsetX, y2D * scale + offsetY);
    }

    // Draw the hypercube
    private async Task DrawHypercubeAsync()
    {
        if (_context == null || _vertices == null) return;

        var projectedVertices = _vertices.Select(ProjectVertex).ToList();

        // Draw edges between vertices
        for (int i = 0; i < _vertices.Count; i++)
        {
            for (int j = 0; j < _vertices.Count; j++)
            {
                if (IsEdge(_vertices[i], _vertices[j]))
                {
                    var start = projectedVertices[i];
                    var end = projectedVertices[j];
                    await _context.BeginPathAsync();
                    await _context.MoveToAsync(start.x, start.y);
                    await _context.LineToAsync(end.x, end.y);
                    await _context.StrokeAsync();
                }
            }
        }

        // Draw vertices
        foreach (var vertex in projectedVertices)
        {
            await _context.BeginPathAsync();
            await _context.ArcAsync(vertex.x, vertex.y, 4, 0, 2 * Math.PI);
            await _context.FillAsync();
        }
    }

    // Check if two vertices are connected by an edge
    private bool IsEdge(double[] v1, double[] v2)
    {
        int diffCount = 0;
        for (int i = 0; i < 4; i++)
        {
            if (v1[i] != v2[i]) diffCount++;
        }
        return diffCount == 1; // Edge if exactly one coordinate differs
    }
}
